### 1.性能优化

#### 大量AJAX请求并发优化方案（高级—美团）

> > **考察：** HTTP协议；端缓存方案；BFF中间层；并发控制
> >
> > **业务背景：** 后端使用微服务，一个接口不能拼接所有需要的数据
>
> **前端—BFF中间层：** 前端中间层对数据进行聚合，减少请求数量。后端微服务场景，用户信息，拜访信息，前端需要大量AJAX请求获取数据并进行拼装。
>
> **前端—请求队列：** 控制请求优先级，有限发送重要请求。
>
> **前端—缓存：** 基于时间缓存（协商缓存）/基于hash缓存（幂等性接口，可以使用拦截器缓存？存疑，对于业务怎么能动拦截器）。
>
> **HTTP—HTTP1.1多域名并发：** 解除浏览器同一时间同一域名发送请求数量的限制。
>
> **HTTP—HTTP1.1自定义头部压缩：** 借鉴HTTP2.0头部压缩方案（参考渡一：一线大厂核心技术方案）。
>
> **HTTP—HTTP2.0：** 



### 2.基础知识挖掘

#### 上传文件展示上传速率方案（中级—京东）

> > **考察：** fetch和XHR的功能边界
>
> **fetch：** 不支持实现，fetch基于promise不便添加状态。分片上传通过分片上传速度可以模糊计算上传速率。
>
> **XHR：** 支持实现，XHR基于事件方便添加相关事件。监听上传时的progress事件。

#### Reflect的作用（高级—字节跳动）

> > **考察：** Reflect
>
> 可以完成对象的基本操作。
>
> **基本操作：** 对象基本操作是ES262文档规定的，对于对象的操作是有限的固定的。浏览器只允许间接调用对象内部方法，Obj.a = 1是间接调用对象内部的[[set]]方法。
>
> **间接调用的副作用：** Object.keys在调用基本操作后做了过滤获取不到非自有或不可枚举属性，但是用Relect.ownKeys直接调用基本操作就不会产生副作用，可以获取所有属性。

#### 对象设置只读属性的方式（中级—途虎）

> > **考察：** 对象特性
>
> **Object.defineProperty：** writable设置为false。
>
> **Object.freeze：** 冻结对象。其它属性也不可修改。
>
> **访问器：** 只设置get不设置set。
>
> **Proxy：** 只用Reflect实现get。

#### WebWorker使用场景（中级—未知）

> > **考察：** web worker
>
> **CPU密集型任务：** 大量字段的表单校验，神经网络的计算
>
> **任务可以被拆分：** 大文件上传分片不可以被拆分

#### 装箱拆箱应用（中级—OPPO）

> > **考察：** 装箱的临时性（隐式类型转换）
>
> ```javascript
> const s = '123'
> s.c = '4'
> s.d = '5'
> 
> const [a, b] = s // 1 2
> const {c, d} = s // undefined undefined
> ```
>
> **装箱—s.c/s.d赋值：** JavaScript中字符串是只读的，任何字符串操作都是针对不可变对象进行的。c属性和d属性赋值都会装箱创建新的字符串实例，不会影响s。
>
> **装箱—a/b/c/d解构：** 原始类型无法参与解构，声明a/b/c/d时s都被装箱成引用类型。

#### 堆内存和栈内存存储内容（初级—小米）

> > **考察：** 原始类型
>
> **错误回答：** 原始类型在栈内存，引用类型存在堆内存。
>
> **栈内存：** 执行上下文中的内容。变量和参数。
>
> **堆内存：**

#### 闭包定义及闭包是否会造成内存泄漏（中级—未知）

> > **考察：** 闭包
>
> **闭包定义：** 在一个函数的环境中，函数本身+它的词法环境是闭包（来源：1966年函数式编程论文，MDN中某个版本对闭包的解释）。
>
> **内存泄漏：**
>
> 如果认为内存泄漏是函数返回的闭包的生命周期结束前制造了不可访问内存，那么闭包可能会产生内存泄漏。
>
> （1）持有了本该被销毁的函数的引用。
>
> （2）多个函数共享词法环境，导致词法环境膨胀。返回的闭包的生命周期结束后原词法环境无法销毁。



### 3.网络场景

#### HTTP2.0的升级点（高级—字节跳动）

> > **考察：** HTTP2.0
>
> **二进制分帧（二进制是实现方式）：**
>
> * 多路复用：解决浏览器同一域名只允许建立6个TCP连接限制
> * 优先级控制
> * 流式传输
> * HTTP队头阻塞
>
> **头部压缩**
>
> **服务端推送**

#### 表格快速切页时保证显示最后一页的结果（中级—拼多多）

> >  **考察：** 请求取消；请求顺序和响应顺序不匹配
>
> **错误回答—锁：** 保证切页时拿到当前数据后再去请求下一页数据，比如设置loading效果。此做法无法做到快速切页。
>
> **错误回答—防抖：** 防抖用于降低事件触发频率，不能解决请求和响应顺序不匹配。响应时间大于防抖时间时还会出现该问题。
>
> **正确回答—前后端—唯一标识：** 模仿IP数据报，给HTTP请求体响应体添加唯一标识，即使乱序也能分辨顺序。
>
> **正确回答—前端—请求取消：** 在上一个请求的响应到达前取消上一次请求。 

#### 地址栏输入URL后发生的事件（中级—未知）

> > **考察：** 计算机网络；浏览器渲染原理
>
> 从计算机网络中贴近前端的层面角度自底向上考虑
>
> **URL检测：** 检查/补全URL。例如：自动补充协议，中文自动编码。
>
> **DNS解析：** 解析DNS。
>
> **TCP请求：** 三次握手建立TCP协议，常见常见下可能存在协议升级到HTTPS，存在SSL握手。
>
> **HTTP请求：** 
>
> > * **准备请求头：** cookie，userAgent等。
> > * **发送请求：** GET请求。
> > * **处理响应头：** setCookie，contentType，cache，status等。
> >
> > * **接收响应体**
>
> **页面渲染：**
>
> > 主线程开始
> >
> > * 解析资源：预处理线程参与解析资源
> > * 样式计算：生成DOM树和CSSOM树（大师课）
> > * Layout：生成布局（大师课）
> > * Layer： 生成分层（大师课）
> > * Paint绘制
> >
> > 主线程结束，合成线程开始（合成线程参与渲染可以使得即使写死循环，页面也可以渲染，页面滚动条可以滚动，只是后续tiles分块进行不了）
> >
> > * tiles分块
> > * 栅格化
> > * draw绘制
>
> **TCP连接断开**



### 4.工程化场景

#### 创建WebWorker时不指定具体文件路径的方案（高级—字节跳动）

> > **考察：** 前端工程化WebWorker部分
> >
> > **业务背景：** 希望打包的worker代码和主线程代码在一个文件里；希望不打包出worker代码；希望worker代码不放到OSS
>
> object url：
>
> data url：

#### 清理源代码中没有被应用的代码（高级—拼多多）

> > **考察：** 前端工程化裁剪源码
>
> Eslint/Terser：开发时，提交代码时（只能做单文件，多文件之间导出变量未使用无法分析）
>
> TreeShaking：打包时（只能支持基于ES模块的css，并且是静态分析；CJS或者ES的动态Import无法解决）
>
> PurgeCSS：CSS原子化
>
> 自定义脚手架：



### 图片水印

### 文件指纹

### E2E测试和前端爬虫

### 前端图片压缩

### 文字水印

### 图片懒加载

### 雪碧图

### 地图Key安全性

### 地图海量点展示

### 大文件上传编码

### 页面失活时的轮询控制

### 扫码登录

### 虚拟列表实现思路

### 虚拟列表滚动白屏问题

### 切换页签丢失定时器精度问题

### 高精度定时器实现思路

### 多人聊天室实现思路

### GPT问答机制实现思路

### 代码结构中消除异步传染性思路

### 联邦模块Webpack配置组件化思路

### 联邦模块共享上下文导致冲突解决思路

### Immer与全量深拷贝

### 国际化实现思路

### 国际化/全球化

### 埋点解决方案

### 性能监控和异常监控

### JSBridge桥接和Cordova桥接

### PWA缓存

**PWA离线方案：**

> 待总结
>
> 微信小程序环境制约，android webview制约，生态封闭
>
> 一般应用缓存能力，离线上传
>
> 谷歌框架

**请简述你对PWA的理解：**

> PWA是普通web应用程序的增强版本，让用户在不同的平台/操作系统上有接近对应平台/操作系统的原生应用程序的良好体验。
>
> 如果想把一个普通web应用程序改进为PWA，那么至少需要支持PWA的这些特性：
>
> * **可安装：** 配置manifest文件。配置图标，是否可以全屏显示等等。
> * **离线操作：** 
>   * 在service worker中拦截各种请求并缓存，离线时发送失败的请求可以被捕获，然后有网络时重新发送。因为Cache Storage是存储在主存储器上。
> * **推送服务：** Notification对象在window上，可以用来推送。后端将消息推送到谷歌中转服务器，然后谷歌服务器推送给web程序。缺点是默认使用谷歌的推送服务，需要翻墙。
> * **平台支持性好：** 应该支持响应式设计，隐藏url栏，工具栏等交互操作。

**请阐述一下服务线程的生命周期？**

> **正常服务线程的生命周期：**
>
> 这并不是一个线性的生命周期，在parsed之后的每个周期，都有可能因为发生错误后进入redunant周期。
>
> * parsed：解析完毕
> * installing：安装中
> * installed：安装完毕
> * activating：激活中
> * activatied：激活完毕
> * redunant：失效
>
> **服务线程工作中生命周期的表现：**
>
> * 页面规定只有一个服务线程，此时没有其它服务线程
>   * 第一次导航事件：正常经历生命周期
>   * 至少第二次导航事件及以后：开始接管程序。第一次导航事件发生后页面可能还有数据没有加载完成，直接接管程序可能造成逻辑错误。
> * 页面规定只有一个服务线程，上次的服务线程未销毁
>   * 第一次导航事件：正常经历生命周期，销毁上个服务线程
>   * 同上

### WebAssembly

#### 内存结构

#### Wasm多线程

#### WebContainer

#### SharedArrayBuffer开启条件
