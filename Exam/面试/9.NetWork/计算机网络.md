### 1.网络模型

#### 计算机网络七层模型作用（寺库）（40s）

> **物理层：**
>
> 实现比特流通过光电等物理介质传输。
>
> **数据链路层：**
>
> 实现两个相邻节点一定程度上的可靠通信。
>
> **网络层：**
>
> 实现数据层面转发IP数据报；控制层面计算路由表。
>
> **传输层：**
>
> 实现进程之间端到端的数据传输。
>
> **会话层：**
>
> 实现设备之间会话的建立。
>
> **表示层：**
>
> 实现数据格式化；数据加密解密；数据压缩。
>
> **应用层：**
>
> 实现应用程序直接调用的接口。

#### 计算机网络七层模型可靠性（130s）

> **物理层：**
>
> > 不可靠。
>
> **数据链路层：**
>
> > 一定程度可靠。但一般使用PPP点到点通信协议。只做校验，错误无法修复。
> >
> > **CRC校验：** 校验数据帧头尾部和数据体，错误直接丢弃。
> >
> > **确认重传机制：** 没有接收到数据帧时支持重传。
> >
> > **数据帧编号机制：** 不按顺序接收数据帧可以重新组装。
>
> **网络层：**
>
> > 一定程度可靠。只做校验，错误无法修复。
> >
> > **IP校验和：** 校验数据报头部，头部错误直接丢弃。
>
> **传输层：**
>
> > 一定程度可靠。篡改无法发现。
> >
> > **建立时—握手挥手：** 稳定建立和释放TCP连接。
> >
> > **传输时—报文编号：** 不按顺序接收时能正确组装。
> >
> > **传输时—报文重传：** 报文丢失或损坏时重传。
> >
> > **传输时—拥塞控制：** 拥塞算法控制发送速率。
> >
> > **传输时—报文校验：** 校验和算法校验头部和数据体。
> >
> > **传输时—流量控制：** 滑动窗口算法控制发送窗口适配接收窗口。
>
> **会话层：**
>
> > 不关注可靠性。
> >
> > **管理会话：** 关注管理会话不关注可靠性。
>
> **表示层：**
>
> > 一定程度可靠。
> >
> > **数据加密：** 数据被篡改时能通过加密解密算法发现。
>
> **应用层：**
>
> > 不关注可靠性。
> >
> > **提供调用接口：** 关注为应用程序提供调用接口不关注可靠性。

#### 计算机网络七层模型协议（150s）

> **物理层：**
>
> > **网卡：** 收发比特流。
> >
> > **集线器：** 将计算机连接到局域网。
> >
> > **调制解调器：** 将数字信号转换为模拟信号。
>
> **数据链路层：**
>
> > **ARP协议：** 提供物理地址寻址标准。
> >
> > * **例如：** 局域网内广播，寻找指定mac地址的主机。
> >
> > **PPP协议：** 提供点到点通信标准。
>
> **网络层：**
>
> > **IP协议：** 提供虚拟地址寻址标准。
> >
> > * **例如：** 局域网直接寻址通信和路由转发寻址通信。
> >
> > **ICMP协议：** 提供错误信息或状态信息传输标准。
> >
> > * **例如：** Windows系统的Ping命令。
> >
> > **BGP协议：** 提供互联网路由选择策略。
> >
> > **RIP/OSPF协议：** 提供内部网关路由选择策略。
> >
> > **IGMP协议：** 提供组播实现标准。
>
> **传输层：**
>
> > **TCP协议：** 传输可靠，传输慢，传输对象一对一。
> >
> > **UDP协议：** 传输不可靠，传输快，传输对象不限定。
>
> **会话层：**
>
> > **PPTP/L2TP（VPN隧道技术相关协议）：** 协议实现了VPN会话的管理。
> >
> > **SSL/TLS协议：** 协议涉及了会话的管理。
>
> **表示层：**
>
> > **SSL/TLS协议：** 协议涉及了数据加密。
>
> **应用层：**
>
> > **HTTP协议：** 传输超文本
> >
> > **SMTP协议：** 传输邮件
> >
> > **FTP协议：** 传输文件
> >
> > **DNS协议：** 解析域名

#### 计算机网络五层模型结构（15s）

> **计算机网络课本五层模型**
>
> > * **应用层**
> >   * **应用层**
> >   * **表示层**
> >   * **会话层**
> > * **传输层**
> > * **网络层**
> >
> > * **数据链路层**
> > * **物理层**

#### 计算机网络四层模型结构（15s）

> **TCP/IP四层模型**
>
> > * **应用层**
> >   * **应用层**
> >   * **表示层**
> >   * **会话层**
> > * **传输层**
> > * **网络层**
> > * **网络接口层**
> >   * **数据链路层**
> >   * **物理层**



### 2.TCP和UDP

#### TCP3次握手过程（20s）

> * 客户端请求建立TCP连接
> * 服务端响应同意建立TCP连接
> * 客户端确认收到服务端的响应
>
> **最终连接建立**

#### TCP3次握手原因（80s）

> **综合来看：**
>
> > 网络通信不可靠，消息在信道中可能丢失或阻塞。三次握手是保证TCP连接可靠建立。
>
> **过程来看：**
>
> > **一次握手：**
> >
> > * **请求丢失时：** 服务端无法收到TCP连接建立请求，流程终止。
> >
> > * **请求阻塞时：** 服务端会建立多条TCP连接，资源浪费。
> >
> > **两次握手：**
> >
> > * **响应丢失时：** 客户端无法收到同意建立TCP连接响应。不发数据。
> >
> > **第三次握手：**
> >
> > 是客户端确认收到来自服务端同意建立TCP连接的响应。这样两者都确定了双方同意建立TCP连接通信，最后TCP连接可以稳定建立。
>

#### TCP第三次握手特点（20s）

> **等待：**
>
> > 客户端发送完确认消息后需要等待一段时间，保证消息没有丢失或阻塞。
>
> **携带数据：**
>
> > 客户端可以在确认消息上携带数据，因为第二次握手时TCP连接已经建立。

#### TCP4次挥手过程（30s）

> * 客户端请求断开TCP连接
> * 服务端响应同意断开TCP连接
> * 服务端响应所有消息传输完毕
> * 客户端确认收到服务端的响应
>
> **最终连接断开**

#### TCP4次挥手原因（90s）

> **综合来看：**
>
> > 网络通信不可靠，消息在信道中可能丢失或阻塞。四次次挥手是保证TCP连接可靠释放。
>
> **过程来看：**
>
> > **一次挥手：**
> >
> > * **请求丢失时：** 服务端无法收到断开TCP连接请求，流程终止。
> >
> > **两次挥手：**
> >
> > * **响应丢失时：** 客户端无法收到同意断开TCP连接响应，流程终止。
> >
> > **三次挥手：**
> >
> > * **响应丢失时：** 客户端无法收到TCP连接剩余数据传输完成响应，持续等待。
> >
> > **第四次挥手：**
> >
> > 是客户端确认收到来自服务端TCP连接剩余数据传输完成的响应。这样两者都确认了双方不再使用TCP连接通信，最后TCP连接可以稳定释放。
>

#### TCP第四次挥手特点（10s）

> **等待：**
>
> > 客户端发送完确认消息后需要等待一段时间，保证消息没有丢失或阻塞。

#### TCP可靠传输策略（60s）

> * **建立时—握手挥手：** 保证连接建立和释放时，能稳定建立释放。
> * **传输时—报文编号：** 保证非顺序接收报文时，能正确组装报文。
> * **阻塞时—报文重传：** 保证报文丢失和阻塞时，能重新请求报文。
> * **阻塞时—拥塞控制：** 保证报文阻塞时，能控制发送速率。
> * **损坏时—报文校验：** 保证报文损坏时，能正确校验错误。
> * **丢失时—流量控制：** 保证报文丢失时，能控制窗口大小。

#### TCP和UDP区别（120s）

> **传输可靠：** 
>
> >  TCP可靠，UDP不可靠。
> >
> >  * **创建：** UDP不关注连接稳定，不可靠；TCP关注连接稳定，需要三次握手和四次挥手，可靠。
> >  * **无序：** UDP不关注报文顺序，不可靠；TCP关注报文顺序，需要报文编号，可靠。
> >  * **阻塞：** UDP不关注报文阻塞，不可靠；TCP关注报文阻塞，需要拥塞控制和报文重传，可靠。
> >  * **损坏：** UDP不关注报文损坏，不可靠；TCP关注报文损坏，需要报文重传和报文校验，可靠。
> >  * **丢失：** UDP不关注报文丢失，不可靠；TCP关注报文丢失，需要流量控制，可靠。
>
> **传输速度：**
>
> > UDP速度快。TCP速度慢。
> >
> > * **头部：** UDP头部字段少；TCP头部字段多。
> > * **创建：** UDP不关注连接稳定，速度快；TCP关注连接稳定，需要三次握手和四次挥手，速度慢。
> > * **无序：** UDP不关注报文顺序，速度快；TCP关注报文顺序，需要报文编号，速度慢。
> > * **阻塞：** UDP不关注报文阻塞，速度快；TCP关注报文阻塞，需要拥塞控制和报文重传，速度慢。
> > * **损坏：** UDP不关注报文损坏，速度快；TCP关注报文损坏，需要报文重传和报文校验，速度慢。
> > * **丢失：** UDP不关注报文丢失，速度快；TCP关注报文丢失，需要流量控制，速度慢。
>
> **传输对象：**
>
> > TCP传输对象一对一，UDP传输对象不限定。
> >
> > * **不限定：** UDP传输对象不限定，因此传输模式都支持（一对一，一对多，多对一，多对多）。
> >
> > * **一对一：** TCP建立连接必须三次握手并是一对一的。

#### TCP和UDP应用场景（100s）

> **传输可靠：**
>
> > **可靠：** TCP应用于文件传输FTP和电子邮件SMTP和网页浏览HTTP。
> >
> > **不可靠：** UDP应用于在线游戏和视频直播和语音通信。
>
> **传输速度：**
>
> > **低速：** TCP应用于文件传输FTP和电子邮件SMTP和网页浏览HTTP。
> >
> > **高速：** UDP应用于在线游戏和视频直播和语音通信。
>
> **传输对象：**
>
> > **一对一：** TCP应用于一对一的文件传输FTP和电子邮件SMTP和网页浏览HTTP。
> >
> > **非一对一：** UDP应用于
> >
> > * **多对一：** 多个游戏玩家和服务器的快速交互
> > * **多对多：** 多个游戏玩家之间快速相互交互
> > * **一对一：** 单个玩家和服务器的快速交互
> > * **一对多：** 广播和组播。



### 3.HTTP

#### HTTP劫持（10s）

> HTTP劫持是一种中间人攻击。
>
> 攻击者拦截HTTP请求或响应，在应用层修改HTTP报文。

#### HTTP方法（50s）

> **资源：**
>
> > * **GET：** 获取服务器资源。是获取全量信息。
> > * **HEAD：** 获取服务器资源。是获取头部信息。
> > * **PUT：** 修改服务器资源。是全量更新操作。
> > * **PATCH：** 修改服务器资源。是局部更新操作。
> >
> > * **POST：** 新增服务器资源。
> >
> > * **DELETE：** 删除服务器资源。
>
> **其它：**
>
> > * **TRACE：** 实现环路测试。例如记录请求和响应途径的路径。
> >
> > * **OPTIONS：** 获取请求支持的方法。例如CORS跨域时预检请求获取跨域支持方。
> > * **CONNECT：** 实现隧道连接建立。例如客户端通过代理服务器和服务端建立隧道TCP连接，传输非HTTP协议数据。

#### HTTP的POST方法使用FormData和Payload场景

> **整体来看：**
>
> > **Payload：** 
> >
> > > * 传输复杂结构化数据。
> > >
> > > * contentType是 ```application/x-www-form-urlencoded``` 和 ```application/json```。
> >
> > **FormData：** 
> >
> > > * 传输简单扁平化数据。
> > > * contentType是 ```multipart/form-data``` 。
>
> **过程来看：**
>
> > FormData传输复杂数据，在append是需要序列化一次。
> >
> > 后端接收时需要先取表单结构，然后对每个字段再反序列化一次。

#### HTTP的GET方法和POST方法区别（50s）

> **语义：**
>
> GET表示获取服务资源。POST表示新增服务器资源。
>
> **数据载体：**
>
> GET通过URL携带数据。POST通过URL或BODY携带数据。
>
> * **举例：** URL携带数据便于页面复现。GET请求页面时：刷新页面数据不丢失；页面可以被保存为书签。
>
> **数据限制：**
>
> GET通过URL携带大量数据时可能会被浏览器截断。POST通过BODY携带数据没有上限。

#### HTTP状态码（150s）

> **100信息状态码**
>
> > 100 Continue：继续请求。
> >
> > * **例如：** 客户端上传大文件发送请求头，服务端返回100再发送请求体。
> >
> > 101 Switching Protocols：切换协议。
> >
> > * **例如：** Http协议要升级到Websocket协议，服务器同意切换则返回101。
>
> **200成功状态码**
>
> > 200 OK：请求成功。
> >
> > 201 Created：创建新资源成功。
> >
> > 202 Accepted：接收到请求但不会立即处理。
> >
> > 206 Partial Content：返回部分内容。
> >
> > * **例如：** 客户端分段下载，断点下载。
>
> **300重定向状态码**
>
> > 301 Moved Permanently：永久重定向。
> >
> > * **例如：** 浏览器会缓存重定向地址。
> >
> > 302 Found：临时重定向。
> >
> > * **例如：** 浏览器不缓存重定向地址。
> >
> > 304 Not Modified：协商缓存时缓存没有发生改变，可以继续使用。
>
> **400客户端错误状态码**
>
> > 400 Bad Request：请求错误
> >
> > * **例如：** 请求语法不对。contnentType错误；参数类型不合法等。
> >
> > 401 Unauthorized：未认证。
> >
> > 403 Forbidden：禁止访问，权限不足。
> >
> > 404 Not Found：未找到资源。
> >
> > 405 Method Not Allowed：请求方法不被允许。
> >
> > * **例如：** 使用CORS跨域，使用非简单方法请求，会先发送一个预检请求preflight，使用options方法。此时服务端要设置字段Access-Control-Allow-Methods，如果客户端发起请求的方法不属于这些规定，那么可以返回405状态码（原生下自己决定返回什么状态码）。例如，SpringBoot中接口要求方法和客户端请求方法不一致，也返回405。
>
> **500服务端错误状态码**
>
> > 500 Internal Server Error：服务器运行错误。
> >
> > 502 Bad Gateway：网关响应错误。
> >
> > * **例如：** nginx转发上游服务器响应时，响应格式不正确；nginx无法与上游服务器连通。
> >
> > 504 Gateway Timeout：网关响应超时。

#### HTTP1.0特点（15s）

> **连接—短连接：**
>
> > **整体来看：**
> >
> > 客户端每次HTTP请求都需要重新建立TCP连接。
>
> **请求—阻塞：**
>
> > **整体来看：**
> >
> > 客户端每次HTTP请求都需要等待上次响应到达后再发送。

#### HTTP1.1特点（150s）

> **对比http1.0：**
>
> > **整体来看：**
> >
> > 提升了请求和响应的速度。通过新增host字段支持虚拟主机技术更灵活部署网站。
>
> **连接—长连接：** 
>
> > **整体来看：**
> >
> > HTTP请求和响应可以复用一个TCP连接。
>
> **请求—管道化：** 
>
> > **整体来看：**
> >
> > 请求可以连续发送，实现流水线。
> >
> > **过程来看：**
> >
> > * **请求：** 即使一个请求的响应没有到达，也可以发送下一个请求。
> >
> > * **响应：** 响应是按顺序的，所以应用层仍然存在队头阻塞问题。
>
> **请求和响应—分块化：**
>
> > **整体来看：**
> >
> > 响应可以分块发送，实现流处理。
> >
> > **过程来看：**
> >
> > 响应头配置 ```Transfer-Encoding: chunked```
>
> **技术—host字段：** 
>
> > **整体来看：**
> >
> > web代理服务器可以根据host字段返回不同网站静态资源，实现虚拟主机技术更灵活部署网站。
>
> **性能—缓存增强：**
>
> > **整体来看：**
> >
> > 增强了缓存控制能力。
> >
> > **过程来看：**
> >
> > * **http1.0：** 
> >   * **缓存行为控制：** 响应Expires控制过期时间，请求Pragma控制缓存行为。
> >   * **文件对比控制：** 请求if-modified-since询问某时间后是否修改。响应last-modified通知上次修改时间。
> > * **http1.1新增：** 
> >   * **缓存行为控制：** 请求和响应Cache-Control支持更丰富缓存配置。响应中主要有 ```no-cache``` 每次都要进行缓存协商， ```no-store``` 不缓存， ```max-age``` 过期时间。
> >   * **文件对比控制：** 请求if-none-match询问标识符是否修改。响应ETag通知最新的文件标识符。

#### HTTP1.1实现断点上传的方式（网易）

> 文件切片上传，携带唯一标识。
>
> 离线断点上传时向服务器询问需要上传哪些切片。
>
> 在线断点上传时向本地存储询问需要上传哪些切片。

#### HTTP1.1复用TCP连接的方式（网易）

> **整体来看：**
>
> 请求页面时服务端响应头默认携带 ```connection: keep-alive``` 启动长连接，使请求和响应可以多次发送。

#### HTTP1.1不能多路复用原因（腾讯）（20s）

>**整体来看：**
>
>HTTP1.1和HTTP2.0传输数据格式不同。
>
>**过程来看：**
>
>多路复用基于流，流基于二进制数据。
>
>HTTP2.0数据传输对象是二进制。HTTP1.1数据传输对象是文本。

#### HTTP2.0多路复用介绍（网易）（25s）

> **整体来看：**
>
> 多路复用基于帧和流实现。
>
> **过程来看：**
>
> 流是多路复用传输的基本单位，帧是流上传输的数据。
>
> 每一对请求和响应都对应一个流。每一个对请求和响应被分割成帧可以在流上双向传输。

#### HTTP2.0特点（120s）

> **对比—http1.1：**
>
> > **整体来看：**
> >
> > 提升了请求和响应的速度。
>
> **连接—多路复用：**
>
> > **整体来看：**
> >
> > 多个请求和响应可以在一个TCP连接上同时发送。在应用层解决了队头阻塞问题。
> >
> > **过程来看：**
> >
> > 多路复用通过流实现，一个流是一个数据通道，对应一对请求和响应。
>
> **格式—头部压缩：**
>
> > **整体来看：**
> >
> > 多个请求和响应可以压缩头部相同字段。在头部只记录不同字段。
>
> **格式—二进制分帧：**
>
> >**整体来看：**
> >
> >二进制指的是头部和数据体编码成二进制，二进制编码面向底层便于扩展和解析。
> >
> >分帧指的是请求和响应被分成了更小的数据帧发送，可以更精细的控制，比如TCP控制分段。
>
> **技术—服务端推送：**
>
> > **整体来看：**
> >
> > 服务端推送资源到客户端缓存。不能直接推送消息给客户端，客户端不能在代码层面监听。
> >
> > **过程来看：**
> >
> > 客户端请求页面时，服务端分析页面，提前把依赖的js，css等文件通过一个连接推送给客户端。

#### HTTP3.0特点（80s）

> **对比—http2.0：**
>
> > **整体来看：**
> >
> > 提升了请求和响应的速度。
>
> **连接—UDP：**
>
> > **整体来看：**
> >
> > 传输层调整成UDP连接，UDP上新增QUIC协议保证可靠传输。
>
> **连接—重复连接：**
>
> > **整体来看：**
> >
> > 网络变化时不需要重复握手，可以快速恢复连接。
> >
> > **过程来看：**
> >
> > 从4G网络突变到WIFI网络，IP地址重新设置。由于QUIC设置了连接ID，对比连接ID即可恢复。
>
> **请求和响应—分帧：**
>
> > **整体来看：**
> >
> > QUIC通过类似HTTP2.0的分帧，在传输层解决HTTP队头阻塞问题。
>
> **技术—加密：**
>
> > **整体来看：**
> >
> > QUIC协议整合了TCP和TLS的机制，HTTP3.0传输默认需要加密。



### 4.DNS

#### DNS劫持（10s）

> 攻击者入侵域名解析服务器，修改域名和IP地址的映射关系。

#### DNS解析过程（30s）

> **综合来看：**
>
> > DNS解析是将域名翻译成IP地址的过程
>
> **过程来看：**
>
> > * **本机：** 本机hosts文件解析
> > * **本地：** 本地域名服务器（内网）解析
> > * **根：** 向根域名服务器询问顶级域名服务器地址
> > * **顶级：** 如果顶级域名服务器有缓存则直接使用，否则向顶级域名服务器询问权限域名服务器地址
> > * **权限：** 向权限域名服务器询问域名IP地址

#### DNS解析优化（10s）

> 自定义plugin扫描项目中的第三方资源引用。添加任何一个到入口html：
>
> ```<link rel="dns-prefetch" href="//example.com">``` 
>
> ```<link rel="preconnect" href="https://example.com">``` 
>
> **dns-prefetch：** 启动dns预解析。
>
> **preconnect：** 包括dns预解析和tcp连接建立/tls连接建立。

#### 解决同一个域名下的并发限制方式

> **并发控制：** 控制并发连接数量，保证域名下还有可用连接。
>
> **扩展域名：** 在连接池中对子域名进行请求分发，重新刷新并发限制。



### 5.实时通信机制

#### 前端实现实时通信的方式

> **短轮询：**
>
> 客户端通过计时器每隔一段时间发送请求。
>
> **长轮询：**
>
> 客户端接收到响应后再发送请求，服务端收到请求后挂起一段时间再响应。
>
> **长连接：**
>
> Websocket长连接通信。SSE长连接通信。

#### Websocket介绍

> **技术—HTTP：**
>
> > 是HTTP协议的升级，请求升级协议时HTTP必须大于等于1.1版本。
>
> **连接—TCP：** 
>
> > 是基于TCP协议。
>
> **连接—长连接：** 
>
> > 是长连接。
>
> **连接—全双工：** 
>
> > 支持同时双向通信。
> >
> > * **无请求响应：** 没有请求和响应的概念，谁对谁发送了消息。
> > * **增强推送能力：** HTTP2.0推送的资源客户端只能在缓存接收，Websocket推送的消息客户端可以直接接收。
>
> **应用—长连接：**
>
> > 需要客户端和服务端双向通信：devserver热更新，在线多人聊天室，在线多人文档编辑。

#### Websocket握手过程

> **第一次握手：**
>
> 客户端发送请求建立WS连接。
>
> 请求头至少携带：
>
> > * **行为：** ```connection: upgrade``` 升级协议。
> > * **目标：** ```upgrade: websocket``` 升级到WS。
> > * **版本：** ```sec-websocket-version``` 升级的WS版本。
> > * **验证字段：** ```sec-websocket-key``` base64编码的16位随机数。
>
> **第二次握手：**
>
> 服务端响应同意建立WS连接。
>
> 响应码是101，表示同意切换协议。
>
> 响应头至少携带：
>
> > * **行为：** ```connection: upgrade``` 已经升级协议。
> > * **目标：** ```upgrade: websocket``` 已经升级到WS。
> > * **版本：** ```sec-websocket-version``` 支持建立的WS版本。
> >
> > * **响应验证字段：** ```sec-websocket-accept``` 用RFC标准规定的固定值和客户端的验证字段进行SHA-1哈希计算返回给客户端。
>
> **sec-websocket作用：**
>
> > key与accept不提供安全性的，只是为了避免客户端配置了相关的connection和upgrade，误请求升级Websocket协议。

#### Websocket相比HTTP的优势

> Websocket服务端可以主动推送消息。
>
> **举例：**
>
> * **聊天室：** 实现聊天室HTTP只能用长轮询或短轮询获取新消息。
> * **HTTP2.0：** HTTP2.0以下协议服务端无法主动推送消息，HTTP2.0只能推送资源到客户端缓存。
> * **SSE：** HTTP1.1以上实现的SSE技术只能能服务端单向推送不能双向通信。

#### SSE介绍

> **技术—HTTP：**
>
> > 是基于HTTP1.1或更高版本实现的技术而不是协议。
>
> **连接—TCP：**
>
> > 是基于TCP协议。
>
> **连接—长连接：**
>
> > 是长连接。
>
> **连接—单向：**
>
> > 只支持服务端向客户端推送，前后端的实现比Websocket简单很多。
>
> **应用—长连接和轻量化：**
>
> > 仅需要服务端推送的场景：GPT回答机器人，股票走向展示。



### 6.加密机制

#### 加密和签名区别

> **公钥和私钥：**
>
> > 公钥可以明文传输，私钥不能传输。
>
> **加密和解密：** 
>
> > 公钥加密，私钥解密。
> >
> > **例如：** 非对称加密。
>
> **签名和验签：** 
>
> > 私钥签名，公钥验签。
> >
> > **例如：** JWT签名验证，CA证书签名验证。

#### 介绍密钥和加密和摘要

> **对称加密：**
>
> > * **原理：** 生成一个私钥。私钥加密和解密。
> > * **安全：** 不安全。密钥管理上交换公钥容易泄漏；密钥破解上如果用短密钥容易被破解。
> >
> > * **速度：** 加密解密速度快。
>
> **非对称加密：**
>
> > * **原理：** 生成一个公钥和私钥。公钥加密私钥解密。
> > * **安全：** 安全。密钥管理上只交换公钥私钥正常不会泄漏；密钥破解上算法决定私钥难被破解。
> >
> > * **速度：** 加密解密速度慢。
>
> **摘要：**
>
> > 用哈希算法把数据处理成固定长度的字符串。处理过程不可逆。

#### 介绍CA证书

> **证书作用：**
>
> CA证书是一个文件，用于保证网络安全传输。
>
> * **信息验证：** 保证加密通信时服务器公钥不被中间人篡改。
>
> * **身份验证：** 保证访问的网站和证书绑定的网站一致。
>
> **证书内容：**
>
> * **服务器公钥：** 服务器公钥
> * **服务器信息：** 服务器信息
> * **证书信息：** 证书过期时间，证书版本，签名算法等。
> * **CA签名：** CA机构的私钥对服务器公钥和信息的签名。

#### CA证书验证过程

> **CA链：**
>
> 每一层CA的公钥放在上层CA私钥签发的数字证书中。根CA用自己的私钥签名给自己颁布证书。
>
> **验证CA链：**
>
> 客户端根据当前网站的证书依次下载CA链上的证书并验证。最终到达根CA时由于客户端都是默认安装根CA证书，因此可以完成整个CA链的验证。

#### TLS握手过程

> <font color=red>**注意：两个随机数是RFC标准规定的，非对称加密算法体现在预主密钥的生成。RSA必须客户端生成传递预主密钥给服务端，DH算法是客户端和服务端直接计算生成。**</font>
>
> **例如：使用RSA算法的TSL1.2**
>
> **第一次握手：**
>
> > **客户端请求：** 
> >
> > * 支持的TLS版本
> > * 支持的加密套件
> > * 第一随机数
>
> **第二次握手：**
>
> > **服务端响应：** 
> >
> > * 使用的TLS版本
> > * 使用的加密套件
> > * 第二随机数
> > * 公钥
> > * 证书
>
> **第三次握手：**
>
> > **客户端操作：** 
> >
> > * **验证：** 证书合法性
> > * **加密：** 公钥加密预主密钥
> > * **生成：** 预主密钥配合随机数生成会话密钥
> >
> > **客户端请求：** 
> >
> > * 公钥加密的预主密钥
>
> **第四次握手：**
>
> > **服务端操作：**
> >
> > * **解密：** 私钥解密被加密的预主密钥
> >
> > * **生成：** 预主密钥配合随机数生成会话密钥
> >
> > **服务端响应：** 
> >
> > * 会话密钥加密的响应消息



### 7.认证机制

#### 介绍JWT（60s）

> **用途：**
>
> > JWT（Json Web Token）用于描述身份验证令牌字符串的格式。
>
> **格式：**
>
> > **头部：** 描述签名算法，一般是加密算法。
> >
> > **身体：** 描述携带的非敏感信息，比如JWT过期时间，用户ID和用户角色。
> >
> > **尾部：** 把头部和身体的Base64编码进行签名的结果。
>
> **存储和传输：**
>
> > JWT的存储和传输没有限制，可以存储到cookie，localStorage等，可以通过cookie或header或body等方式传输。
>
> **安全性：**
>
> > 服务端通过签名算法对前两部分重新签名，如果得到的签名和JWT尾部不同，则JWT被篡改。

#### JWT存储位置选取（10s）

> 一般考虑放到localStorage（或其他本地存储方式）或者cookie中。两种存储情况都不安全，本地存储需要防御XSS攻击，cookie存储需要防御XSS和CSRF攻击。

#### JWT主动登出实现（20s）

> **黑名单**
>
> 登出用户的ID加入redis黑名单，验证JWT时，检查用户ID是否处于黑名单。处于黑名单则直接将JWT过期。
>
> **双token**
>
> 长短过期时间token配合认证中心实现，认证中心设置长token过期，短token过期后无法再次刷新。

#### JWT过期续签实现（50s）

> **单应用**
>
> 后端控制，自动刷新过期时间
>
> **单点登录**
>
> * **认证中心：** 设置认证中心连接多个服务，用于校验登录信息和续签token。
>
> * **双token：** 设置短token验证身份，长token续签短token。短token过期时利用长token续签，长token过期时退出登录或向认证中心续签。
> * **原因：** 设置长token可以让认证中心控制所有服务节点。

#### 前端单点登录结构（15s）

> **不跨域**
>
> 不同产品都在一个域名或子域名下，可以通过共享cookie来完成身份验证。
>
> **跨域**
>
> 后端配置认证中心，前端配合使用双token来控制身份认证和身份登出。
