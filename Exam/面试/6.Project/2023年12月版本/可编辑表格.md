### 1.实现

#### 1.1 引入

可编辑表格指每个单元格都可以嵌入业务组件，点击后直接进行编辑和校验。当前业务要求至少支持不分页的3000行30列的实时编辑。

#### 1.2 实现思路

**第一版想法—优化Form：**

> 老版本代码是在antd表格的基础上，做了自定义行和自定义列，每行都是一个Form，编辑完单元格后不刷新数据源。希望借助antd的Form处理大数据量的问题，但是发现antd的Form效率不是很高，直接无法处理数据量大的情况，因此放弃。

**第二版想法—优化列表：**

> * **虚拟列表支持自定义单元格和行：** 在优化Form失败后，希望在表格中插入虚拟列表解决大数据情况下滚动问题。但是项目必须使用antd4.0，在antd4.0中没有antd支持的虚拟列表库，必须引用antd以外的第三方虚拟列表库。但是发现主流的虚拟列表库都是不支持自定义行和单元格，因为自定义行和列用于处理虚拟列表逻辑了。但是我们需要行插入Form，单元格需要处理很多逻辑，因此拉了第三方轻量级的虚拟列表库进行调整，支持自定义单元格和行。
> * **缓存机制：** 在虚拟列表滚动时，当前行滚出视口后销毁，Form的实例中存储的数据和单元格校验状态都会消失，因此需要做缓存。

**第三版想法—优化逻辑：**

> 接入虚拟列表后其实不需要在使用Form，因为展示的数据量很少，因此修改后直接刷新数据源即可。并且长度为3000的数组做浅拷贝性能负担也不大。



### 2.滚动过快的白屏问题

#### 2.1 引入

参考主流的虚拟列表库（react-window，virutalList-antd，rc-virutal-list），都存在滚动过快时列表部短暂白屏的情况。

#### 2.2 渲染原理

**上述虚拟列表库的列表DOM结构大致如下：**

> * 列表容器，允许滚动
>   * 高度超高的列表，撑起高度使容器滚动条出现
>     * 渲染容器，和列表容器高度相同

**实现虚拟滚动的原理大致如下：**

> * 用户拉动滚动条或鼠标滚轮滚动触发滚动事件
> * 合成器线程优先响应用户输入，不需要等待主线程计算和渲染
> * virtualList-antd是在主线程在事件监听器中监听到滚动事件之后计算长列表的padding-top，把渲染容器顶到可视部分。

#### 2.3 白屏原因

合成器线程没有等待主线程的计算和渲染，所以计算并渲染长列表的padding-top的时间要晚于滚动事件的生效。因此用户会先滚动到长列表的无内容区域，出现白屏，这个白屏其实就是长列表的背景色。

#### 2.4 解决方案

**修改虚拟滚动的实现原理：**

> 项目中引入了轻量级的virtualList-antd，只有500行左右的代码，因此直接拷贝源代码在源代码基础上做修改：
>
> 因为计算滚动距离和将渲染容器重新渲染到可视区域一定要晚于滚动事件，并且是底层的浏览器控制的，对业务来说是不可控的。因此计划省略这个计算的过程，将渲染容器一直固定在可视区域内。
>
> * 因为要保证长列表撑起高度，让外层容器出现滚动条。因此DOM结构不变。
> * 因为要让渲染容器固定在可视区域，因此渲染容器要相对于最外层容器定位。
> * 考虑兼容性问题：
>   * 在antd中采用这种方法发现遮挡了表格中的滚动条，需要给横向和纵向滚动条预留位置。又要区分不同浏览器和不同操作系统，滚动条的表现形式和宽度都不一样。
>   * 在antd中采用这种方法发现还要考虑表格中固定列的问题，有时候导致样式丢失，设置表格单元格固定高度即可。
>   * 在antd中采用这种方法发现还要考虑表格中列尾部的占位块的问题，样式调整和滚动条位置调整类似

**规避滚动事件：**

> react-component中的虚拟列表在几个月前更新了。用overflow禁用了浏览器默认的滚动条，使用自定义的滚动条。使用div块模拟滚动条效果，div滚动时肯定默认并不会带动列表滚动。因此当我们捕获滚动事件到重新渲染之前，列表会保持原有状态，不会出现短暂的白屏问题。



### 3.海量单元格校验问题

#### 3.1 引入

用户在编辑完可编辑表格后提交前需要再做一次校验，判断输入值是否合法。由于单元格至少在10w个以上，因此直接校验会很慢。

**尝试方法：**

> * 直接使用antd的Form进行校验：速度极慢。
> * 提取antd的Form中用到的校验库，自己写校验函数：速度还是很慢，大概7到8秒校验完成。
> * 尝试异步校验：直接卡死，异步校验太多会阻塞微任务，导致其它事件无法响应。

#### 3.2 线程池实现原理：

* **对数据源切片：** 校验3000行30列的单元格，可以切成10份。因为不使用线程池校验的话，校验时间在7到8秒，希望校验时间在1秒内，并且考虑线程调度时间，因此切片成10份进行线程调度校验。
* **线程分配：** 
  * 有空闲线程则直接分配，修改线程和线程池状态。
  * 无空闲线程则返回一个promise给业务，将resolve的resolve方法加入线程的等待队列。
  * 业务调用时有空闲线程，则直接postMessage通信，启动线程处理校验。
  * 业务调用时如果无空闲线程，则将处理逻辑放入promise的then中。
* **线程终止：** 
  * 直接终止，修改线程和线程池状态。
  * 等待队列第一个元素出列，并执行resolve方法，通知业务线程可以使用。
* **线程池销毁：** 
  * 当校验完成时，由业务调用线程池方法，销毁所有线程。

#### 3.3 线程池打包问题：

因为只是简单调用 ```new Worker``` 功能，因此没有引入第三方控制工作线程的库。

工作线程对应的代码放到该组件的子目录下。



### 4.全键盘问题：

#### 4.1 引入

全键盘指的是只通过键盘来编辑单元格，可以通过方向键回车等按键进行单元格切换或保存。

#### 4.2 逻辑介绍

**切换单元格聚焦策略和问题：**

> * 切换单元格就是当前单元格失焦并做检验进行保存，之后对下一个指定位置的可编辑单元格进行聚焦。
> * 在聚焦前需要先手动触发普通单元格的点击或者聚焦事件，通知单元格要展示业务自定义的编辑组件，之后再触发业务组件的聚焦方法或手动去寻找input聚焦。

**切换单元格场景和逻辑：**

> * **单元格是否考虑混杂情况：** 考虑可编辑和不可编辑单元格同时出现。
> * **单元格如何定位：** 给单元格添加自定义属性标序号，确定当前单元格位置，便于上下左右操作。
> * **聚焦元素如何保证显示在视口内：** 滚动时保证聚焦的元素能在视口显示，正常情况视口外的元素聚焦会带动滚动事件，例如虚拟列表设置了缓冲区，能保证上下聚焦超出视口时带动列表上下滑动。但是左右滑动可能会被固定的列（fixed定位）遮挡，在左右聚焦时，还要考虑设置表格的左右偏移量。
> * **全键盘优先级如何考虑：** 组件内部的全键盘操作优先级高，例如antd的select，业务下拉表格控件。



### 5.Form的性能问题：

#### 5.1 rc-field-form的性能测试：

* 向Form中插入6000个Field，每个Field中插入一个普通的文本框。在文本框输入时非常卡顿。
* 向页面中插入6000个普通文本框。文本框输入不卡顿。

#### 5.2 卡顿逻辑：

Form实现结构：

> * useForm返回form实例，携带常见的表单操作方法
> * Form组件使用context向下传递一些方法和属性
> * FieldForm组件涉及一些更新逻辑
> * FormStore状态管理器中注册了所有FieldForm，表单值

Form更新逻辑：

> 由于表单项之间可能存在依赖，因此每次更新时都会依据FormStore中注册的FieldForm来收集依赖，需要对所有的FieldForm进行遍历和处理。但实际上业务中的FieldForm是可以看作是独立的，不需要写依赖。

